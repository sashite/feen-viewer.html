<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FEEN Viewer</title>

  <!-- SEO Meta Tags -->
  <meta name="description" content="Interactive web viewer for FEEN (Field Expression Encoding Notation) board positions. Supports Chess, Shōgi, Xiangqi, and other abstract strategy games with cross-style hybrid positions.">
  <meta name="keywords" content="FEEN, Field Expression Encoding Notation, chess notation, board games, chess viewer, shogi, xiangqi, game notation, board position">
  <meta name="author" content="Cyril Kato">
  <meta name="robots" content="index, follow">
  <link rel="canonical" href="https://sashite.github.io/feen-viewer.html/">

  <!-- Open Graph Meta Tags -->
  <meta property="og:title" content="FEEN Viewer - Board Game Position Viewer">
  <meta property="og:description" content="Interactive web viewer for FEEN (Field Expression Encoding Notation). Visualize Chess, Shōgi, Xiangqi and hybrid board game positions.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://sashite.github.io/feen-viewer.html/">
  <meta property="og:image" content="https://sashite.github.io/feen-viewer.html/favicon/web-app-manifest-512x512.png">
  <meta property="og:image:alt" content="FEEN Viewer Logo">
  <meta property="og:site_name" content="FEEN Viewer">
  <meta property="og:locale" content="en_US">

  <!-- Twitter Card Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="FEEN Viewer - Board Game Position Viewer">
  <meta name="twitter:description" content="Interactive web viewer for FEEN (Field Expression Encoding Notation). Visualize Chess, Shōgi, Xiangqi and hybrid board game positions.">
  <meta name="twitter:image" content="https://sashite.github.io/feen-viewer.html/favicon/web-app-manifest-512x512.png">
  <meta name="twitter:image:alt" content="FEEN Viewer Logo">

  <!-- Favicons -->
  <link rel="icon" type="image/png" href="favicon/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="favicon/web-app-manifest-192x192.png" sizes="192x192">
  <link rel="icon" type="image/png" href="favicon/web-app-manifest-512x512.png" sizes="512x512">
  <link rel="icon" type="image/svg+xml" href="favicon/favicon.svg">
  <link rel="shortcut icon" href="favicon.ico">
  <link rel="apple-touch-icon" sizes="180x180" href="favicon/apple-touch-icon.png">
  <meta name="apple-mobile-web-app-title" content="FEEN Viewer">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">

  <!-- PWA -->
  <link rel="manifest" href="site.webmanifest">
  <meta name="theme-color" content="#ffffff">

  <!-- Stylesheets -->
  <style>
    @charset "UTF-8";

    :root {
      --font-size-base: 2vmin;
      --square-size: 5vmin;
      --accent-color: #e6f0ff;
      --board-border: #cccccc;
      --text-color: #333;
      --error-color: #d32f2f;
      --error-bg: #ffebee;
      --section-bg: #f9f9f9;
      --border-radius: 4px;
      --board-cols: 8;
    }

    body {
      max-width: 90vw;
      margin: 0 auto;
      padding: 2vmin;
      color: var(--text-color);
      line-height: 1.5;
      font-size: var(--font-size-base);
    }

    header h1 {
      margin-bottom: 0.5vmin;
    }

    hr {
      border: none;
      border-top: 1px solid var(--board-border);
      margin: 3vmin 0;
    }

    form {
      margin-bottom: 2vmin;
    }

    input {
      width: 100%;
      padding: 1vmin;
      border: 1px solid var(--board-border);
      border-radius: var(--border-radius);
      font-size: var(--font-size-base);
      margin-bottom: 1vmin;
      box-sizing: border-box;
      padding-left: 1vmin;
    }

    input:focus {
      outline: 2px solid var(--accent-color);
      border-color: #999;
    }

    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    small {
      display: block;
      font-size: calc(var(--font-size-base) * 0.8);
      color: #666;
      margin-bottom: 1vmin;
    }

    button {
      background-color: var(--text-color);
      color: white;
      border: none;
      border-radius: var(--border-radius);
      padding: 1vmin 2vmin;
      cursor: pointer;
      font-size: var(--font-size-base);
      transition: opacity 0.2s ease;
    }

    button:hover {
      opacity: 0.9;
    }

    button:focus {
      outline: 2px solid var(--accent-color);
      outline-offset: 2px;
    }

    table {
      border-collapse: collapse;
      margin: 2vmin auto;
      max-width: calc(var(--board-cols) * var(--square-size));
      width: 100%;
    }

    table caption {
      padding: 1vmin;
      font-weight: bold;
      font-size: calc(var(--font-size-base) * 1.2);
    }

    td {
      border: 1px solid var(--board-border);
      text-align: center;
      aspect-ratio: 1/1;
      position: relative;
      padding: 0;
      width: calc(100% / var(--board-cols));
      min-width: var(--square-size);
      min-height: var(--square-size);
    }

    tr {
      display: grid;
      grid-template-columns: repeat(var(--board-cols), 1fr);
    }

    tr:nth-child(odd) td:nth-child(even),
    tr:nth-child(even) td:nth-child(odd) {
      background-color: var(--accent-color);
    }

    .piece {
      font-family: monospace;
      font-size: calc(var(--font-size-base) * 1.5);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
    }

    td .piece {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100%;
      height: 100%;
      font-size: calc(var(--square-size) * 0.6);
    }

    li .piece {
      display: inline-flex;
      vertical-align: middle;
      margin-right: 0.5vmin;
    }

    .lowercase {
      color: black;
    }

    .uppercase {
      color: red;
    }

    dl {
      margin: 2vmin 0;
      padding: 1.5vmin;
      background-color: var(--section-bg);
      border-radius: var(--border-radius);
      border: 1px solid #e0e0e0;
    }

    dt {
      font-weight: bold;
      margin-top: 1vmin;
      font-size: calc(var(--font-size-base) * 0.95);
    }

    dt:first-child {
      margin-top: 0;
    }

    dd {
      margin-left: 0;
      margin-bottom: 1vmin;
      padding-left: 1vmin;
      border-left: 3px solid var(--accent-color);
    }

    dd:last-child {
      margin-bottom: 0;
    }

    dd ul {
      padding-left: 0;
      margin: 0.5vmin 0;
      list-style-type: none;
    }

    dd li {
      display: inline-block;
      margin-right: 1vmin;
      margin-bottom: 0.5vmin;
      padding: 0.3vmin 0.6vmin;
      background-color: white;
      border: 1px solid #ddd;
      border-radius: calc(var(--border-radius) / 2);
    }

    footer {
      margin-top: 4vmin;
    }

    footer section {
      margin-bottom: 2vmin;
    }

    footer section h2 {
      font-size: calc(var(--font-size-base) * 1.1);
      margin-bottom: 1vmin;
      color: var(--text-color);
    }

    footer section p {
      margin-bottom: 1vmin;
      line-height: 1.6;
    }

    footer section:last-child {
      margin-bottom: 0;
    }

    a {
      color: #0066cc;
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    a:focus {
      outline: 2px solid var(--accent-color);
      outline-offset: 1px;
    }

    a[rel="external"]::after {
      content: " ↗";
      font-size: 0.8em;
      opacity: 0.7;
    }

    .error {
      color: var(--error-color);
      background-color: var(--error-bg);
      padding: 1.5vmin;
      border-radius: var(--border-radius);
      border: 1px solid #ffcdd2;
      margin: 2vmin 0;
    }

    .error p {
      margin: 0;
      font-weight: 500;
    }

    @media (max-width: 480px) {
      :root {
        --font-size-base: 3vmin;
        --square-size: 6vmin;
      }

      body {
        max-width: 95vw;
        padding: 1.5vmin;
      }

      dd {
        padding-left: 0.5vmin;
        border-left-width: 2px;
      }

      input {
        padding-left: 1vmin;
      }

      table {
        max-width: calc(var(--board-cols) * var(--square-size));
      }

      td {
        min-width: calc(var(--square-size) * 0.8);
        min-height: calc(var(--square-size) * 0.8);
      }
    }

    @media (min-width: 1200px) {
      :root {
        --font-size-base: 18px;
        --square-size: 50px;
      }

      body {
        max-width: 1000px;
      }
    }

    @media print {
      header form,
      footer,
      hr {
        display: none;
      }

      body {
        max-width: 100%;
        padding: 0;
        font-size: 12pt;
      }

      table {
        margin: 0;
      }

      .piece {
        color: black !important;
      }
    }
  </style>

  <!-- Scripts -->
  <script>
    /**
     * FEEN Viewer - A viewer for FEEN v1.0.0 notation
     * Implements the FEEN specification version 1.0.0
     * Dependencies: EPIN v1.0.0, SIN v1.0.0
     */

    document.addEventListener('DOMContentLoaded', () => {
      // ========================================================================
      // EPIN Token Validation (per EPIN v1.0.0 specification)
      // Format: [state-modifier] letter [terminal-marker] [derivation-marker]
      // ========================================================================

      /**
       * EPIN regex pattern per specification §5
       * Anchored to whole string, rejects line breaks
       */
      const EPIN_PATTERN = /^[-+]?[A-Za-z]\^?'?$/;

      /**
       * Validates an EPIN token
       * @param {string} token - The token to validate
       * @returns {boolean} True if valid EPIN token
       */
      function isValidEpin(token) {
        if (!token || typeof token !== 'string') return false;
        if (token.includes('\r') || token.includes('\n')) return false;
        return EPIN_PATTERN.test(token);
      }

      /**
       * Parses an EPIN token into its components
       * @param {string} token - A valid EPIN token
       * @returns {Object} Parsed components
       */
      function parseEpin(token) {
        if (!isValidEpin(token)) {
          throw new Error(`Invalid EPIN token: "${token}"`);
        }

        let i = 0;
        let stateModifier = null;
        let letter = null;
        let terminalMarker = false;
        let derivationMarker = false;

        // Check for state modifier (+ or -)
        if (token[i] === '+' || token[i] === '-') {
          stateModifier = token[i];
          i++;
        }

        // Get the letter (required)
        letter = token[i];
        i++;

        // Check for terminal marker (^)
        if (i < token.length && token[i] === '^') {
          terminalMarker = true;
          i++;
        }

        // Check for derivation marker (')
        if (i < token.length && token[i] === "'") {
          derivationMarker = true;
          i++;
        }

        return {
          stateModifier,
          letter,
          terminalMarker,
          derivationMarker,
          // Derived properties per EPIN §6
          pieceName: letter.toUpperCase(),
          pieceSide: letter === letter.toUpperCase() ? 'first' : 'second',
          pieceState: stateModifier === '+' ? 'enhanced' : stateModifier === '-' ? 'diminished' : 'normal',
          isTerminal: terminalMarker,
          isDerived: derivationMarker
        };
      }

      /**
       * Extracts base letter from EPIN token (for sorting)
       * @param {string} token - EPIN token
       * @returns {string} The letter component
       */
      function getEpinBaseLetter(token) {
        const match = token.match(/[A-Za-z]/);
        return match ? match[0] : '';
      }

      // ========================================================================
      // SIN Token Validation (per SIN v1.0.0 specification)
      // Format: exactly one ASCII letter
      // ========================================================================

      /**
       * SIN regex pattern per specification §4.3
       * Anchored to whole string
       */
      const SIN_PATTERN = /^[A-Za-z]$/;

      /**
       * Validates a SIN token
       * @param {string} token - The token to validate
       * @returns {boolean} True if valid SIN token
       */
      function isValidSin(token) {
        if (!token || typeof token !== 'string') return false;
        if (token.includes('\r') || token.includes('\n')) return false;
        return SIN_PATTERN.test(token);
      }

      /**
       * Parses a SIN token
       * @param {string} token - A valid SIN token
       * @returns {Object} Parsed components
       */
      function parseSin(token) {
        if (!isValidSin(token)) {
          throw new Error(`Invalid SIN token: "${token}"`);
        }

        return {
          abbr: token.toUpperCase(),
          side: token === token.toUpperCase() ? 'first' : 'second',
          raw: token
        };
      }

      // ========================================================================
      // FEEN Parsing (per FEEN v1.0.0 specification)
      // ========================================================================

      /**
       * Parses a FEEN string into its three fields
       * @param {string} feenString - The FEEN notation string
       * @returns {Object} The parsed fields
       */
      function parseFeen(feenString) {
        // §6.1: MUST NOT contain leading or trailing whitespace
        if (!feenString || typeof feenString !== 'string') {
          throw new Error('Invalid FEEN: must be a non-empty string');
        }

        // §6.1: Line breaks MUST NOT appear anywhere
        if (feenString.includes('\r') || feenString.includes('\n')) {
          throw new Error('Invalid FEEN: must not contain line breaks');
        }

        const trimmed = feenString.trim();
        if (trimmed !== feenString) {
          throw new Error('Invalid FEEN: must not have leading or trailing whitespace');
        }

        if (!trimmed) {
          throw new Error('Invalid FEEN: must be a non-empty string');
        }

        // §6: Three fields separated by single ASCII spaces
        const parts = trimmed.split(' ');

        if (parts.length !== 3) {
          throw new Error('Invalid FEEN format: must contain exactly three space-separated fields');
        }

        const [piecePlacement, hands, styleTurn] = parts;

        // Validate each field is non-empty
        if (!piecePlacement) {
          throw new Error('Invalid FEEN: piece placement field cannot be empty');
        }
        if (!hands) {
          throw new Error('Invalid FEEN: hands field cannot be empty');
        }
        if (!styleTurn) {
          throw new Error('Invalid FEEN: style–turn field cannot be empty');
        }

        return { piecePlacement, hands, styleTurn };
      }

      /**
       * Analyzes the style–turn field per FEEN §9
       * @param {string} styleTurn - The style–turn field from FEEN
       * @returns {Object} Parsed style–turn information
       */
      function parseStyleTurn(styleTurn) {
        if (!styleTurn || typeof styleTurn !== 'string') {
          throw new Error('Invalid style–turn: must be a non-empty string');
        }

        // §9: Format is <ACTIVE-STYLE>/<INACTIVE-STYLE>
        const slashIndex = styleTurn.indexOf('/');
        if (slashIndex === -1) {
          throw new Error('Invalid style–turn format: must contain "/" separator');
        }

        const activeStyle = styleTurn.substring(0, slashIndex);
        const inactiveStyle = styleTurn.substring(slashIndex + 1);

        // Validate both are valid SIN tokens (single ASCII letter)
        if (!isValidSin(activeStyle)) {
          throw new Error(`Invalid active style: "${activeStyle}" is not a valid SIN token (must be exactly one ASCII letter)`);
        }
        if (!isValidSin(inactiveStyle)) {
          throw new Error(`Invalid inactive style: "${inactiveStyle}" is not a valid SIN token (must be exactly one ASCII letter)`);
        }

        // §9.3: The two STYLE tokens MUST be of opposite case
        const activeIsUpper = activeStyle === activeStyle.toUpperCase();
        const inactiveIsUpper = inactiveStyle === inactiveStyle.toUpperCase();

        if (activeIsUpper === inactiveIsUpper) {
          throw new Error('Invalid style–turn format: one style must be uppercase and one lowercase');
        }

        // §9.1: Uppercase = first player, lowercase = second player
        // §9.2: First position = active player
        const activePlayerSide = activeIsUpper ? 'first' : 'second';
        const firstPlayerStyle = activeIsUpper ? activeStyle : inactiveStyle;
        const secondPlayerStyle = activeIsUpper ? inactiveStyle : activeStyle;

        return {
          activeStyle,
          inactiveStyle,
          activePlayerSide,
          firstPlayerStyle,
          secondPlayerStyle
        };
      }

      /**
       * Parses the hands field per FEEN §8
       * @param {string} handsField - The hands field from FEEN
       * @returns {Object} Parsed hands for both players
       */
      function parseHands(handsField) {
        if (!handsField || typeof handsField !== 'string') {
          throw new Error('Invalid hands: must be a string');
        }

        // §8: Format is <FIRST-HAND>/<SECOND-HAND>
        const slashIndex = handsField.indexOf('/');
        if (slashIndex === -1) {
          throw new Error('Invalid hands format: must contain "/" separator');
        }

        // Check there's only one slash
        if (handsField.indexOf('/', slashIndex + 1) !== -1) {
          throw new Error('Invalid hands format: must have exactly one "/" separator');
        }

        const firstHandStr = handsField.substring(0, slashIndex);
        const secondHandStr = handsField.substring(slashIndex + 1);

        const firstPlayerHand = parseHandItems(firstHandStr, 'first');
        const secondPlayerHand = parseHandItems(secondHandStr, 'second');

        return { firstPlayerHand, secondPlayerHand };
      }

      /**
       * Parses hand items from a hand string per FEEN §8.1-8.2
       * @param {string} handStr - The hand string to parse
       * @param {string} playerLabel - 'first' or 'second' for error messages
       * @returns {Array} Array of {piece, count} objects
       */
      function parseHandItems(handStr, playerLabel) {
        if (handStr === '') {
          return [];
        }

        const items = [];
        let i = 0;

        while (i < handStr.length) {
          let count = 1;

          // §8.2: If next char is digit, read maximal digit sequence as count
          if (/[0-9]/.test(handStr[i])) {
            // Check for leading zero (not allowed per §8.1)
            if (handStr[i] === '0') {
              throw new Error(`Invalid ${playerLabel} hand: count cannot start with 0`);
            }

            const numStart = i;
            while (i < handStr.length && /[0-9]/.test(handStr[i])) {
              i++;
            }
            count = parseInt(handStr.slice(numStart, i), 10);

            // §8.1: If count is present, it MUST be >= 2
            if (count < 2) {
              throw new Error(`Invalid ${playerLabel} hand: explicit count must be >= 2`);
            }
          }

          // Now read the EPIN token
          if (i >= handStr.length) {
            throw new Error(`Invalid ${playerLabel} hand: count without piece token`);
          }

          // Read EPIN token: [+-]?[A-Za-z][^]?[']?
          const tokenStart = i;

          // Optional state modifier
          if (handStr[i] === '+' || handStr[i] === '-') {
            i++;
          }

          // Required letter
          if (i >= handStr.length || !/[A-Za-z]/.test(handStr[i])) {
            throw new Error(`Invalid ${playerLabel} hand: expected piece letter at position ${i}`);
          }
          i++;

          // Optional terminal marker
          if (i < handStr.length && handStr[i] === '^') {
            i++;
          }

          // Optional derivation marker
          if (i < handStr.length && handStr[i] === "'") {
            i++;
          }

          const piece = handStr.slice(tokenStart, i);

          if (!isValidEpin(piece)) {
            throw new Error(`Invalid ${playerLabel} hand: "${piece}" is not a valid EPIN token`);
          }

          items.push({ piece, count });
        }

        // Validate canonical ordering per §10.2
        validateHandOrdering(items, playerLabel);

        return items;
      }

      /**
       * Validates that hand items are in canonical order per FEEN §10.2
       * @param {Array} items - Array of {piece, count} objects
       * @param {string} playerLabel - For error messages
       */
      function validateHandOrdering(items, playerLabel) {
        for (let i = 1; i < items.length; i++) {
          const prev = items[i - 1];
          const curr = items[i];

          const cmp = compareHandItems(prev, curr);
          if (cmp > 0) {
            throw new Error(`Invalid ${playerLabel} hand: items not in canonical order`);
          }
          if (cmp === 0) {
            throw new Error(`Invalid ${playerLabel} hand: duplicate items should be aggregated`);
          }
        }
      }

      /**
       * Compares two hand items for canonical ordering per FEEN §10.2
       * @returns {number} Negative if a < b, positive if a > b, 0 if equal
       */
      function compareHandItems(a, b) {
        // 1. By multiplicity – descending (larger counts first)
        if (a.count !== b.count) {
          return b.count - a.count;
        }

        const aParsed = parseEpin(a.piece);
        const bParsed = parseEpin(b.piece);

        // 2. By EPIN base letter – case-insensitive alphabetical order
        const aLetter = aParsed.letter.toLowerCase();
        const bLetter = bParsed.letter.toLowerCase();
        if (aLetter !== bLetter) {
          return aLetter.localeCompare(bLetter);
        }

        // 3. By EPIN letter case – uppercase before lowercase
        const aIsUpper = aParsed.letter === aParsed.letter.toUpperCase();
        const bIsUpper = bParsed.letter === bParsed.letter.toUpperCase();
        if (aIsUpper !== bIsUpper) {
          return aIsUpper ? -1 : 1;
        }

        // 4. By EPIN state modifier – '-' before '+' before none
        const stateOrder = { '-': 0, '+': 1, null: 2 };
        const aState = stateOrder[aParsed.stateModifier] ?? 2;
        const bState = stateOrder[bParsed.stateModifier] ?? 2;
        if (aState !== bState) {
          return aState - bState;
        }

        // 5. By EPIN terminal marker – absent before present
        if (aParsed.terminalMarker !== bParsed.terminalMarker) {
          return aParsed.terminalMarker ? 1 : -1;
        }

        // 6. By EPIN derivation marker – absent before present
        if (aParsed.derivationMarker !== bParsed.derivationMarker) {
          return aParsed.derivationMarker ? 1 : -1;
        }

        return 0;
      }

      /**
       * Parses a segment (rank/row) into placement tokens per FEEN §7.3-7.4
       * @param {string} segmentStr - The segment string to parse
       * @returns {Array} Array where each element is either an EPIN string or null (empty)
       */
      function parseSegment(segmentStr) {
        const cells = [];
        let i = 0;

        while (i < segmentStr.length) {
          const char = segmentStr[i];

          // §7.3: Empty-count token (integer >= 1, no leading zeros)
          if (/[1-9]/.test(char)) {
            const numStart = i;
            while (i < segmentStr.length && /[0-9]/.test(segmentStr[i])) {
              i++;
            }
            const emptyCount = parseInt(segmentStr.slice(numStart, i), 10);

            for (let k = 0; k < emptyCount; k++) {
              cells.push(null);
            }
            continue;
          }

          // Leading zero is invalid for empty-count
          if (char === '0') {
            throw new Error(`Invalid piece placement: leading zero in empty-count at position ${i}`);
          }

          // §7.3: Piece token (valid EPIN token)
          const tokenStart = i;

          // Optional state modifier
          if (char === '+' || char === '-') {
            i++;
            if (i >= segmentStr.length || !/[A-Za-z]/.test(segmentStr[i])) {
              throw new Error(`Invalid piece placement: state modifier without letter at position ${tokenStart}`);
            }
          }

          // Required letter
          if (!/[A-Za-z]/.test(segmentStr[i])) {
            throw new Error(`Invalid piece placement: expected letter at position ${i}`);
          }
          i++;

          // Optional terminal marker
          if (i < segmentStr.length && segmentStr[i] === '^') {
            i++;
          }

          // Optional derivation marker
          if (i < segmentStr.length && segmentStr[i] === "'") {
            i++;
          }

          const piece = segmentStr.slice(tokenStart, i);

          if (!isValidEpin(piece)) {
            throw new Error(`Invalid piece placement: "${piece}" is not a valid EPIN token`);
          }

          cells.push(piece);
        }

        return cells;
      }

      /**
       * Parses the piece placement field per FEEN §7
       * @param {string} piecePlacement - The piece placement field
       * @returns {Object} Parsed board data
       */
      function parsePiecePlacement(piecePlacement) {
        if (!piecePlacement || typeof piecePlacement !== 'string') {
          throw new Error('Invalid piece placement: must be a non-empty string');
        }

        // §7.2: Field MUST NOT start or end with /
        if (piecePlacement.startsWith('/')) {
          throw new Error('Invalid piece placement: must not start with "/"');
        }
        if (piecePlacement.endsWith('/')) {
          throw new Error('Invalid piece placement: must not end with "/"');
        }

        // Check if this is a multi-dimensional board beyond 2D
        if (piecePlacement.includes('//')) {
          throw new Error('Only 1D and 2D boards are supported in this viewer');
        }

        // Split into segments by /
        const segmentStrs = piecePlacement.split('/');

        if (segmentStrs.length === 0) {
          throw new Error('Invalid piece placement: no segments found');
        }

        // Parse each segment
        const segments = segmentStrs.map((segStr, idx) => {
          if (segStr === '') {
            throw new Error(`Invalid piece placement: empty segment at position ${idx}`);
          }
          return parseSegment(segStr);
        });

        // Determine max width for grid
        const maxWidth = Math.max(...segments.map(s => s.length));

        return {
          segments,
          maxWidth,
          height: segments.length
        };
      }

      // ========================================================================
      // Display Functions
      // ========================================================================

      /**
       * Main function to parse FEEN and display the position
       * @param {string} feenString - The FEEN notation string
       */
      function displayPosition(feenString) {
        try {
          main.innerHTML = '';

          // Parse FEEN string into three fields
          const { piecePlacement, hands, styleTurn } = parseFeen(feenString);

          // Parse each field
          const styleTurnData = parseStyleTurn(styleTurn);
          const handsData = parseHands(hands);
          const boardData = parsePiecePlacement(piecePlacement);

          // Create display elements
          const firstPlayerDL = createPlayerDL(
            styleTurnData.firstPlayerStyle,
            handsData.firstPlayerHand,
            true
          );
          const secondPlayerDL = createPlayerDL(
            styleTurnData.secondPlayerStyle,
            handsData.secondPlayerHand,
            false
          );
          const boardTable = createBoardTable(
            boardData,
            styleTurnData.activeStyle,
            styleTurnData.activePlayerSide
          );

          // Display: inactive player at top, active player at bottom (chess convention)
          const isFirstPlayerActive = styleTurnData.activePlayerSide === 'first';
          const activePlayerDL = isFirstPlayerActive ? firstPlayerDL : secondPlayerDL;
          const inactivePlayerDL = isFirstPlayerActive ? secondPlayerDL : firstPlayerDL;

          main.appendChild(inactivePlayerDL);
          main.appendChild(boardTable);
          main.appendChild(activePlayerDL);

        } catch (error) {
          main.innerHTML = `<div class="error"><p>Error: ${error.message}</p></div>`;
        }
      }

      /**
       * Creates a definition list for a player
       * @param {string} style - The SIN style token
       * @param {Array} pieces - The pieces in hand
       * @param {boolean} isFirstPlayer - Whether this is the first player
       * @returns {HTMLElement} The definition list
       */
      function createPlayerDL(style, pieces, isFirstPlayer) {
        const dl = document.createElement('dl');

        const styleDt = document.createElement('dt');
        styleDt.textContent = 'Style';

        const styleDd = document.createElement('dd');
        styleDd.textContent = style;

        const piecesDt = document.createElement('dt');
        piecesDt.textContent = 'Pieces in hand';

        const piecesDd = document.createElement('dd');

        if (pieces.length === 0) {
          piecesDd.textContent = 'None';
        } else {
          const ul = document.createElement('ul');

          for (const { piece, count } of pieces) {
            const li = document.createElement('li');
            const pieceSpan = document.createElement('span');
            pieceSpan.className = 'piece';

            const displayText = count > 1 ? `${count}${piece}` : piece;
            pieceSpan.textContent = displayText;

            // Color based on controlling player (first = uppercase/red, second = lowercase/black)
            if (isFirstPlayer) {
              pieceSpan.classList.add('uppercase');
            } else {
              pieceSpan.classList.add('lowercase');
            }

            li.appendChild(pieceSpan);
            ul.appendChild(li);
          }

          piecesDd.appendChild(ul);
        }

        dl.appendChild(styleDt);
        dl.appendChild(styleDd);
        dl.appendChild(piecesDt);
        dl.appendChild(piecesDd);

        return dl;
      }

      /**
       * Creates a board table from parsed board data
       * @param {Object} boardData - Parsed board data from parsePiecePlacement
       * @param {string} activeStyle - The active player's style
       * @param {string} activePlayerSide - 'first' or 'second'
       * @returns {HTMLElement} The board table
       */
      function createBoardTable(boardData, activeStyle, activePlayerSide) {
        const { segments, maxWidth } = boardData;

        // Determine if we need to flip the board (when second player is active)
        const shouldFlipBoard = activePlayerSide === 'second';

        const table = document.createElement('table');

        const caption = document.createElement('caption');
        caption.textContent = `${activeStyle}'s turn`;
        table.appendChild(caption);

        // Prepare rows for display
        const displayRows = shouldFlipBoard ? [...segments].reverse() : segments;

        for (const segment of displayRows) {
          const tr = document.createElement('tr');
          tr.style.gridTemplateColumns = `repeat(${maxWidth}, 1fr)`;

          // Prepare cells for display
          const displayCells = shouldFlipBoard ? [...segment].reverse() : segment;

          for (const cell of displayCells) {
            const td = document.createElement('td');

            if (cell !== null) {
              const pieceElement = document.createElement('span');
              pieceElement.className = 'piece';

              // Parse the EPIN token to determine side
              const parsed = parseEpin(cell);

              if (parsed.pieceSide === 'first') {
                pieceElement.classList.add('uppercase');
              } else {
                pieceElement.classList.add('lowercase');
              }

              pieceElement.textContent = cell;
              td.appendChild(pieceElement);
            }

            tr.appendChild(td);
          }

          // Pad with empty cells if needed
          for (let j = displayCells.length; j < maxWidth; j++) {
            const td = document.createElement('td');
            tr.appendChild(td);
          }

          table.appendChild(tr);
        }

        return table;
      }

      // ========================================================================
      // Initialization
      // ========================================================================

      const form = document.querySelector('form');
      const main = document.querySelector('main');

      // Parse initial FEEN from input field on page load
      displayPosition(document.querySelector('input[name="feen"]').value);

      // Handle form submission
      form.addEventListener('submit', (event) => {
        event.preventDefault();
        const feenInput = form.querySelector('input[name="feen"]').value;
        displayPosition(feenInput);
      });
    });
  </script>

  <!-- JSON-LD Structured Data -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "FEEN Viewer",
    "alternateName": "Field Expression Encoding Notation Viewer",
    "description": "Interactive web viewer for FEEN (Field Expression Encoding Notation) board positions. Supports Chess, Shōgi, Xiangqi, and other abstract strategy games with cross-style hybrid positions.",
    "url": "https://sashite.github.io/feen-viewer.html/",
    "applicationCategory": "GameApplication",
    "operatingSystem": "Web Browser",
    "browserRequirements": "Requires JavaScript",
    "softwareVersion": "1.0.0",
    "dateCreated": "2025-06-09",
    "creator": {
      "@type": "Person",
      "name": "Cyril Kato",
      "url": "https://cyril.email/"
    },
    "publisher": {
      "@type": "Person",
      "name": "Cyril Kato",
      "url": "https://cyril.email/"
    },
    "license": "https://opensource.org/licenses/MIT",
    "programmingLanguage": "JavaScript",
    "screenshot": "https://sashite.github.io/feen-viewer.html/favicon/web-app-manifest-512x512.png",
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "USD"
    },
    "featureList": [
      "FEEN v1.0.0 notation parsing and validation",
      "EPIN v1.0.0 piece token support",
      "SIN v1.0.0 style identifier support",
      "Visual board representation",
      "Support for Chess, Shōgi, Xiangqi positions",
      "Cross-style hybrid position support",
      "Captured pieces display",
      "Canonical ordering validation",
      "Responsive design",
      "Real-time position updates"
    ],
    "keywords": "FEEN, Field Expression Encoding Notation, chess notation, board games, chess viewer, shogi, xiangqi, game notation, board position",
    "inLanguage": "en",
    "isAccessibleForFree": true,
    "mainEntity": {
      "@type": "SoftwareApplication",
      "name": "FEEN Position Viewer",
      "applicationCategory": "Utility",
      "description": "Parse and visualize board game positions in FEEN format"
    }
  }
  </script>
</head>
<body>
  <header>
    <h1>FEEN Viewer</h1>
    <form>
      <label for="feen-input" class="visually-hidden">Enter FEEN notation string</label>
      <input
        id="feen-input"
        type="text"
        name="feen"
        placeholder="e.g. +rnbq+k^bn+r/+p+p+p+p+p+p+p+p/8/8/8/8/+P+P+P+P+P+P+P+P/+RNBQ+K^BN+R / C/c"
        value="+rnbq+k^bn+r/+p+p+p+p+p+p+p+p/8/8/8/8/+P+P+P+P+P+P+P+P/+RNBQ+K^BN+R / C/c"
        aria-describedby="feen-help">
      <small id="feen-help">Enter a valid FEEN notation string to visualize the board position</small>
      <button type="submit">Load Position</button>
    </form>
  </header>

  <hr>

  <main>
    <p>The position should be generated here.</p>
  </main>

  <hr>

  <footer>
    <section class="about">
      <h2>About FEEN</h2>
      <p>
        FEEN (Field Expression Encoding Notation) is a rule-agnostic, canonical position encoding
        for two-player, turn-based board games built on the Sashité Game Protocol.
      </p>
      <p>
        FEEN strings consist of three space-separated fields:
        <strong>&lt;PIECE-PLACEMENT&gt;</strong> (board configuration using EPIN tokens),
        <strong>&lt;HANDS&gt;</strong> (pieces in each player's hand), and
        <strong>&lt;STYLE–TURN&gt;</strong> (styles and active player using SIN tokens).
      </p>
      <p>
        Learn more about the <a href="https://sashite.dev/specs/feen/1.0.0/" rel="external">FEEN v1.0.0 Specification</a>.
      </p>
    </section>

    <section class="examples">
      <h2>Example FEEN Strings</h2>
      <dl>
        <dt>Chess Starting Position</dt>
        <dd><code>+rnbq+k^bn+r/+p+p+p+p+p+p+p+p/8/8/8/8/+P+P+P+P+P+P+P+P/+RNBQ+K^BN+R / C/c</code></dd>

        <dt>Shōgi Starting Position</dt>
        <dd><code>lnsgk^gsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGK^GSNL / S/s</code></dd>

        <dt>Cross-Style Game (Chess vs Makruk)</dt>
        <dd><code>rnsmk^snr/8/pppppppp/8/8/8/+P+P+P+P+P+P+P+P/+RNBQ+K^BN+R / C/m</code></dd>

        <dt>Irregular Board Shape</dt>
        <dd><code>rk^r/pp/PPPP / G/g</code></dd>

        <dt>1D Chess Board (size 8) Starting Position</dt>
        <dd><code>k^+p4+PK^ / C/c</code></dd>
      </dl>
    </section>

    <section class="legal">
      <p>
        © 2025 <a href="https://cyril.email/" rel="external">Cyril Kato</a>.
        All content including <a href="https://github.com/sashite/feen-viewer.html" rel="external">source code</a> and
        <a href="https://github.com/sashite/feen-logo.svg" rel="external">logo</a> released under the
        <a href="https://opensource.org/licenses/MIT" rel="external">MIT License</a>.
      </p>
    </section>
  </footer>
</body>
</html>
